//
//  LongestConsecutiveSubsequence.swift
//  Test-DSTests
//
//  Created by Moazam Abass Mir on 4/9/25.
//

import Foundation
import Testing
/*
 Given an array of integers nums, return the length of the longest consecutive sequence of elements that can be formed.

 A consecutive sequence is a sequence of elements in which each element is exactly 1 greater than the previous element. The elements do not have to be consecutive in the original array.

 You must write an algorithm that runs in O(n) time.

 Example 1:
 Input: nums = [2,20,4,10,3,4,5]
 Output: 4
 Explanation: The longest consecutive sequence is [2, 3, 4, 5].

 Example 2:
 Input: nums = [0,3,2,5,4,6,1,1]
 Output: 7

 */

/// NOTE: This code was rated 7/10 as a recursive solution by Claude 3.7 and one interesting points raised was due to copying of string
func lcs(a: String, b: String) -> Int {
	if a.isEmpty || b.isEmpty {
		return 0
	}
	let aEndIndex  = a.index(before: a.endIndex)
	let bEndIndex = b.index(before: b.endIndex)

	if a[aEndIndex] == b[bEndIndex] {
		return 1 + lcs(a: String(a.dropLast()), b: String(b.dropLast()))
	} else {
		return max(lcs(a: String(a.dropLast()), b: b), lcs(a: a, b: String(b.dropLast())))
	}
}

/// This one was generated by Claude 3.7 and was given a score of 8.5 and I like this better.
func lcs(_ a: String, _ b: String) -> Int {
	// Convert strings to arrays once for efficient character access
	let aChars = Array(a)
	let bChars = Array(b)

	// Use a helper function that works with arrays and indices
	return lcsHelper(aChars, bChars, aChars.count - 1, bChars.count - 1)
}

private func lcsHelper(_ a: [Character], _ b: [Character], _ i: Int, _ j: Int) -> Int {
	// Base case: if either index is negative, return 0
	if i < 0 || j < 0 {
		return 0
	}

	// If characters match, include this character and recur for the rest
	if a[i] == b[j] {
		return 1 + lcsHelper(a, b, i - 1, j - 1)
	} else {
		// Characters don't match, take maximum of two possible subproblems
		return max(
			lcsHelper(a, b, i - 1, j),
			lcsHelper(a, b, i, j - 1)
		)
	}
}

private func lcsHelperInt(_ a: [Int], _ b: [Int], _ i: Int, _ j: Int) -> Int {
	// Base case: if either index is negative, return 0
	if i < 0 || j < 0 {
		return 0
	}

	// If characters match, include this character and recur for the rest
	if a[i] + 1 == b[j]  {
		return 1 + lcsHelperInt(a, b, i - 1, j - 1)
	} else {
		// Characters don't match, take maximum of two possible subproblems
		return max(
			lcsHelperInt(a, b, i - 1, j),
			lcsHelperInt(a, b, i, j - 1)
		)
	}
}

func longestConsecutive(nums: [Int]) -> Int {
	return lcsHelperInt(nums.sorted(), nums.sorted(), nums.count - 1, nums.count - 1) + 1
}

@Test func lcsInt() {

	print("FIrst", longestConsecutive(nums: [2,20,4,10,3,4,5]))
	print("Yoo\(longestConsecutive(nums: [0,3,2,5,4,6,1,1]))")

}
/*
 [0,3,2,5,4,6,1,1]
 [0,3,2,5,4,6,1,1]
 */



@Test("basic")
func testLCS() async throws {
	print(lcs(a: "abcdef", b: "actkf"))
}

